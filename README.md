# Automata
CSED341: Automata & Formal Languages

## Book

Introduction to Automata Theory, Languages, and Computations
by John E. Hopcroft, Rajeev Motwani, Jeffrey D. Ullman.

---

## 1. Preliminaries

- Formal proof
    - adequate proof
    - Deduction
    - Induction
    - Contradiction
- Automata theory
    - study of abstract computing machines or models
- Alphabets(∑)
    - Finite, non-empty set of symbols
- Strings
    - finite sequence of symbols
    - empty string ε. |ε| = 0
    - Σ^k. length k. Σ^* ⇒ all strings
    - w^0 = ε, εw = wε =w, wv = connect
- Languages
    - A set of strings from Σ^*
- Finite automata
    - computing machines with finite number of states

---

## 2. Finite Automata

- start →, arc, final O*2
- DFA(Deterministic Finite Automata)
    - current state to only state
    - unique computation
    - M = (Q, Σ, δ, q0, F)
    - Q : finite state set
    - δ : transition function
    - q0 : start state
    - F : set of final state
- NFA(non-Deterministic Finite Automata)
    - several state at once
- Transition function δ(q,a)
    - state q, input symbol a
    - accept when end in final state
- Extended transition function δhat
    - δhat (q,ε) = q
    - δhat (q,wa) = δ (δhat (q,w),a)
- Language of a DFA, NFA
    - L(M) = { w ∈ Σ* | δhat (q0,w) ∈ F}
    - L(M) = { w ∈ Σ* | δhat (q0,w) ∩F ≠ Φ}
    - the set of accepted strings
- Regular Language
    - L = L(M) exist, L : regular language
- Automata Equivalence
    - L(M1) = L(M2), M1,M2 equivalent
    - DFA & NFA
        - DFA ⇒ NFA p to {p}
        - NFA ⇒ DFA subset construction
            - δD(S,a) = ∪δN(q,a)
            - input to union set
            - Induction with w.
- NFA with ε transitions
    - ε input.
    - ε-Closure
        - Follow ε, reach state
- Transition diagram
    - state circle
    - transition function arrow
- Transition table
    - arrow → start state
    - star * final state

---

## 3. Regular expressions

- Operators.
    - Union (+)
    - Concatenation (dot) LM
    - Kleene star(star-closure) L* = ∪ Li
    - empty set * = {ε}
- Regular expression
    - type of language description
    - +, dot, *
    - operation closed
    - Commutative : Union, ordered concatenation
    - Associative
    - Distributive law
    - Identities, annihilator(Φ): Φr = rΦ = Φ.
    - idempotent : r+r = r
- Language L(r)
    - denoted by regular expression
    - L(r1 + r2) = L(r1) ∪ L(r2)
    - L(r1r2) = L(r1) L(r2)
    - L((r1)) = L(r1)
    - L(r*) = (L(r))*
    - set express the re
- RE → NFA
    - induction on the # of operators
    - operators to state machine
    - Generalized NFA
        - transition graph : edges are labeled with RE
        - canonical form : only start, final state
- NFA → RE
    - L = L(r) r exist
        - let M : NFA accept L
        - with removing state, canonical form

---

## 3B. Regular Grammars

- Grammar G=(V, T, S, P)
    - V : variables. non empty
    - T : Terminal symbols. non empty
    - S : Start variable
    - P : Productions rules
    - give P to make own grammar
        - ex) L= {a^n b^(n+1)}. P : S → aSb or S→b
- Linear grammar
    - one variable can occur any side of production.
    - left-linear = right-linear = regular grammar
    - Language is regular < = > regular grammar
    - ⇒
        - L : regular, DFA M exist L = L(M)
        - P = A→ wB, A→ε
    - <=
        - NFA M(Q, Σ, δ, q0, F) accept L : generated by G
        - Q = V ∪ F
        - Σ = T
        - δ : δ(A,w) = B (A →wB), δ(A,w) = f (A →w)
        - q0 = S
        - F = {f}
    - Mixed X regular

---

## 4. Properties of Regular Languages

- Identify Non-regular Languages
- Pigeonhole Principle
    - Suppose L regular
    - By Pigeonhole principle, there exist (m≠n) s.t. δhat (q0, a^n) = q, δhat (q0, a^m) = q
    - δhat (q, b^m) = qf
    - M accept only m = n, contradiction!
- Pumping lemma
    - L : regular language, w = xyz
    - For each i ≥0, x y^i z ∈ L
    - y ≠ ε
    - | xy | ≤ p
- Decision properties of RL
    - Membership problem
        - decision property
    - Emptiness problem
        - the language contain all strings?
    - Infiniteness problem
        - RL infinite? state < string length ⇒ infinite
        - # of path state
    - Equivalence problem
        - L = M? make product DFA Q × R
        - product automaton's language is empty < = > L=M
    - Containment problem
        - L ⊆ M?
- Closure properties
    - union, concatenation, star-closure ⇒ shown by RE
    - Complementation
    - Intersection : proof
    - Difference : L1 - L2 = L1 ∩ L2bar
    - Reversal
    - Homomorphism
        - function h : alphbet to alphabet. connection to strings
        - substitution
    - Inverse Homomorphism
        - h ( h^-1 (L)) = L False
- Minimum state DFA
    - indistinguishable states
        - δhat (p,w) ∈ F ⇒ δhat (q,w) ∈ F
        - transitivity p→q q→r : p→r
    - unite all indistinguishable states
    - result is fewest with algorithms with table
        - No unrelated smaller DFA
            - Start states are indistinguishable. induction using transitivity

---
